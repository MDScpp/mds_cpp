---
marp: true
auto-scaling: true
style: |
  .hidden  {
    opacity: 0.0;
  }
  
---

# Лекция 2. Функции   

---

# План лекции 

- функция main, точка входа в программу
- Операторы
- Циклы и операторы break; continue;
- Объявления переменных
  - Указатели
  - ссылки
- Введение в сложные типы (структуры) 
- Перегрузка функций 
- Перегрузка операторов
- Средства сборки 

---

<style scoped>
:not(h1){
  font-size: 22px
}
</style>

# Функции 

- почти любые вычисления описываются внутри функций, функций членов
- функция состоит из набора инструкций (statments)
- expression statments выражение после которого следует точка с запятой `;`
- точкой входа в программу является функция main()
- всего 9 типов инструкций: labeled; expression; compound; selection; iteration; jump; declaration; try blocks; atomic and synchronized blocks
```cpp
int main() {  // тело функции ограничивается фигурными скобками 
    int n = 1;             // declaration statement
    n = n + 1;             // expression statement  // n+n - expression, n=n+n тоже expression 
    if (n < 5)             // start of selection statement // кроме if еще есть switch 
    {                      // start of block
        int k = 1;         // declaration statement
        std::cout << k +1; // expression statement
    }                      // end of block, end of if statement
    // в с++  табуляции и пробелы не имеют такого значения как в Python, можно это все написать в одну строку
    return 0;                         // return statement
} 
```


---

# Определение функции 

<style scoped>
code{
  font-size: 22px
}
</style>

``` 
тип_возвращаемый имя_функции(параметры) {
    инструкции
}
```

```cpp
// функция принимает 3 аргумента, возвращает значение типа long long int  
long long int sumAll(int a, int b, int c = 0){
  int g = a+b;
  return g+c; //тут используется  неявное приведение типов (с повышением)
}

// функция без аргументов, и ничего не возвращает
void printMessage() { // void - используется для обозначения того, что функция ничего не возвращает

    std::cout << "Hello, world!" << std::endl;
}
```

---
# Обьявление функции 
Объявление функции вводит имя функции и ее тип. Определение функции связывает имя/тип функции с телом функции.

```cpp
// вы можете писать или не писать имена аргументов (компилятор игнорирует это). 
// можно определять аргументы по умолчанию как в python 
long long int sumAll(int a, int = 10 , int c = 0);

void printMessage();
```

При вызове функций, компилятор должен знать о функции (о ее сигнатуре возвращаемом и принимаемым типах) до ее вызова. Поэтому вызов функции должен происходить после ее обьявления или определения (вызов должен стоять ниже по тексту)

---


<style scoped>
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 15px;
}
th, td {
  border: 1px solid #ddd;
  padding: 1px;
  text-align: center;
  white-space: nowrap;
}
th {
  background-color: #007acc;
  color: white;
}
</style>

## Операторы, [приоритет операторов](https://en.cppreference.com/w/cpp/language/operator_precedence)

| П | Оператор(ы) | Описание | Ассоциативность |
|-----------|------------|----------|-----------------|
| 1 | `::` | Scope resolution | ---> |
| 2 | `a++` `a--` (постфиксные), `()` (вызов функции), `[]` (обращение по индексу), `.` `->` (доступ к членам) | Постфиксные операции | ---> |
| 3 | `++a` `--a` (префиксные), `+` `-` (унарные), `!` `~`, `*` (разыменование), `&` (взятие адреса), `sizeof`, `alignof`, `new` `delete`, `typeid`, `co_await` | Унарные операции | <--- |
| 4 | `.*` `->*` | указатель на член | ---> |
| 5 | `*` `/` `%` | Умножение, деление, остаток  | ---> |
| 6 | `+` `-` | Сложение, вычитание | ---> |
| 7 | `<<` `>>` | Побитовые сдвиги | ---> |
| 8 | `<` `<=` `>` `>=` | Операции сравнения | ---> |
| 9 | `==` `!=` | Проверка на равенство | ---> |
| 10 | `&` | Побитовая И | ---> |
| 11 | `^` | Побитовая XOR | ---> |
| 12 | `\|` | Побитовая ИЛИ | ---> |
| 13 | `&&` | Логическая И | ---> |
| 14 | `\|\|` | Логическая ИЛИ | ---> |
| 15 | `?:` | Тернарный оператор | <--- |
| 16 | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `\|=` `<<=` `>>=` | Операторы присваивания | <--- |
| 17 | `throw` | Оператор исключений | <--- |
| 18 | `,` | Оператор запятая | ---> |



---

#  Присваивание, Инкремент и декркмент

Присваивание тоже возвращает значение, и в это значение(выражение) можно что-то класть;

```cpp
float af = 0 ,bf =1 , cf= 2;
af=bf=cf; // результат: af = 2, bf = 2, cf = 2 

af = 0 ,bf = 1, cf= 2; //заполняем нужными нам значениями
                      // используя оператор  <,>

(af=bf)=cf; // результат: af = 2, bf = 1, cf = 2 
// другие операторы присваиваний 
af+=af+1; // эквивалент (af=af+af+1);
af+=bf+=cf; // эквивалент af = af+ (bf=bf+cf);  
```
Зачем нужно? Так можно записывать некоторые вещи короче, но не стоит использовать больше одного присваивания в одном выражении. 

---

# Инкремент/декремет 

- бывают префиксные и постфиксные: `++a`,`--b` и `a++`, `a++`. 
- позволяют увеличить зачение переменной.
## Префиксный 
```cpp
int b, a = 0;
// пример инкремента
b = ++a; // тоже самое что и:  b=(a+=1);  или вот так: b=(a=a+1);
(++a = 10); // можно даже так, хоть сысла это не имеет
someFunctionCall( &(++a)) ; // зато это имеет смысл 
```


---

## Постфиксный инкремент и декремент 
- бывают префиксные и постфиксные.
- позволяют увеличить зачение переменной.
- Несмотря на всю свою похожесть, постфиксные инкременты и декременты работают несколько иначе. Результату работы декремента нельзя присваивать, но разумеетя этот "результат" можно присвоть-чему-нибудь, так как результатом является новое значение уже не связанное с изначальной местом в памяти. 

```cpp
int b, a = 0;
b = a++; // результатом будет  b = 0  и a = 1
// (a++ = 10); // так делать уже не получится 
// someFunctionCall( &(++a)) ;  // и так тоже 
```


---




# Compound statements (составные инструкции)
синтаксис: ``` { statment... } ```
```cpp

int main()
{ // начало внешнего блока compound-statement	
    {                           // начало внутреннего блока  compound-statement	
        ofstream f("test.txt"); // declaration statement
        f << "abc\n";           // expression statement
    }                           // конец , здесь для f будет вызван деструктор 
    ifstream f("test.txt"); // declaration statement
    string str;             // declaration statement
    f >> str;               // expression statement
} // конец внешнего блока, str будет уничтожен, f is closed
```
переменные, объявленные внутри блока, уничтожаются закрывающей скобкой в ​​обратном порядке;


---

# Iteration statements

1) ```while ( expression ) statement```  проверка условия на входе 
2) ```do  statement  while ( expression ) ;``` проверка условия на выходе 
3) ```for ( init-statement ;  expression1 (opt) ; expression2 (opt) ) statement```

инструкция for эквивалентна  следующему

```cpp
{
  init-statement
  while ( condition )
  {
    statement
    expression ;
  }
}
```

есть еще один тип циклов [range-for](https://en.cppreference.com/w/cpp/language/range-for) , но об этом позже

---

# Jump statements (инструкции перехода)

1) ```break;``` - Заставляет цикл или оператор switch завершиться. Если циклы вложенны, завершает только один цикл а не все!!! 
2) ```continue;``` Приводит к пропуску оставшейся части тела цикла, 
3) ```return expression (opt);``` производит выход из функции;
4) ```return braced-init-list;``` ; производит выход из функции;
5) ```goto label;``` statement. под страхом смерти не используйте 

порядок уничтожения противоположен порядку инициализации;

---

# Declaration statement (инструкции объявления)
## декларирование указателей
<table>
<tr><th>указатели на константы</th><th>константные указатели</th> </tr>
<tr><td>

```cpp
const int a = 6; 
const int *p = &a; 
// без разницы где ставить const
int const *q = &a;  

p = 0;    // все хорошо 
*p = 13;  // ошибка во время 
          // компиляции 
```

</td><td>

```cpp

int a = 6;
int *const p = &a;
*p = 13; // ok
p = p + 1; // ошибка во время 
           // компиляции 
int const *const full = &a;

```
</td></tr> </table>

---

# Declaration statement 
## объявление ссылок

  ```cpp
  // Ссылка – это псевдоним для существующего объекта
  int a = 10;
  int& ref = a; // ref – это другое "имя" для a
  ref = 20;  // Теперь a == 20

  // Ссылки нельзя "перенаправить"
  int x = 5, y = 10;
  int& ref = x;
  ref = y;  // ref изменяет x, а не перенаправляется на y!

  //️ Ссылки должны быть инициализированы при объявлении
  int& r; //  Ошибка! Нужно сразу присвоить значение

  // Константные ссылки могут ссылаться на временные объекты
  const int& ref2 = 10; // ОК: создается временная переменная
  ```

---
## Еще про ссылки
  
```cpp
#include <iostream>
// Передача параметров по ссылке позволяет менять переменную
void modify(int& x) { x += 2; }  // Передача по ссылке

// Передача по const-ссылке предотвращает изменение 
// и позволяет экономить ресурсы
void print(const std::string& s) { std::cout << s; } // Без копирования!

int main(){
  int x = 5;
  modify(x);
  std::cout << x; // будет выведено 7
  return 0;
};
```

*  Ссылки могут быть rvalue (&&) — для перемещения объектов, но об этом на 4й лекции

---

## Введение в составные типы данных (Struct)


<style scoped>
:not(h2){
  font-size: 19px
}
</style>


Используйте структуру только для пассивных объектов, которые несут данные; для всего остального есть классы. (в д.з. мы будем игнорировать это правило)


<table>
<tr></tr>
<tr><td>

```cpp
struct MySt{
    uint32_t id;
    char flag;
    uint32_t value;
    char foo;
}

int main(){
    // обьявляем b 
    // и инициализирууем
    MySt a {1,0b101,3,4};
    MySt * a_p = &a; 
    a.id = 100; 
    a_p->flag = 0b101;  
}
```
</td></tr> </table>

![bg right:40% 100%](images/struct.drawio.svg)

---


```cpp

struct MySt{
    uint32_t id;
    char flag;
    uint32_t value;
    char foo;
}

// меняем переданный объект
void fillWithZero( MySt & a ) { a.id=0; a.flag=0; a.value=0; a.foo=0; }
void fillWithOneP( MySt * a ) { a->id=1; a->flag=1; a->value=1; a->foo=1; }
// экономим ресурсы
void printID(const MySt & a) { std::cout << a.id << std::endl; }


int main(){
    MySt a {1,0b101,3,4};
    printID(a);
    fillWithZero(a);
    printID(a);
    fillWithOneP(&a); // сначала берем адрес объекта и уже адрес передаем в функцию 
    printID(a);
}
```

---

# Перегрузка функций


Если имя относится к более чем одной сущности, говорят, что оно перегружено , и компилятор должен определить, какую перегрузку вызвать. Проще говоря, перегрузка, параметры которой наиболее точно соответствуют аргументам, является той, которая вызывается.

```cpp
void f ( long ) ; // это объявления, определения находятся в другой/других 
void f ( float ) ;// единицах трансляции (Translation unit)
 
f ( 0L ) ;  // вызывает f(long)  
f ( 0 ) ;   // ошибка: неоднозначная перегрузка (0 - это int, приведение типов не определено)
```

---

# Внешняя перегрузка операторов
Перегрузка операторов позволяет определить пользовательское поведение операторов (+, -, *, /, =, ==, [], (), ++, -- и др.) для пользовательских типов данных (классов и структур).

---

# Внешняя перегрузка операторов

```cpp
#include <iostream>
struct Point {
    int x, y;
};

bool operator==(const Point& p1, const Point& p2) {
    return (p1.x == p2.x && p1.y == p2.y);
}

Point operator+(const Point& p1, const Point& p2) {
    return {p1.x + p2.x , p1.y + p2.y};
}

Point operator*(const int a, const Point& p) {
    return {a*p.x , a*p.y};
}

int main() {
    Point p1{5, 7}, p2{5, 7}, p3{3, 4};
    // используем тернарный оператор 
    std::cout << (p1 == p2 ? "equal" : "not equal") << std::endl; // Выведет: equal
    std::cout << (p1 == p3 ? "equal" : "not equal") << std::endl; // Выведет: not equal
    auto pp = p1 + 2*p3;
    std::cout << "(" << pp.x << ", " << pp.y << ")";
    return 0;
}
```

---
# Cборка с помощью make 


```make

my_program: main.o utils.o example.o
  clang++ main.o utils.o example.o -o my_program

main.o: main.cpp
  clang++ -c main.cpp

utils.o: utils.cpp utils.h
  clang++ -c utils.cpp

example.o: example.cpp example.h
  clang++ -c example.cpp

all: example

clean:
  rm -f *.o my_program

```

---
# Cборка с помощью make 

- При первом запуске cmake генерирует файл зависимостей, где фиксируются все зависимости .cpp файлов от .h файлов.  (он сам заглядывает в них)
- При изменении заголовочного файла компилятор пересобирает все .cpp файлы, которые его используют.

```cmake
cmake_minimum_required(VERSION 3.10)

project(MyProgram)

set(CMAKE_CXX_STANDARD 17)

add_executable(my_program main.cpp utils.cpp example.cpp)
```
```
mkdir build 
cd build
ccmake ../ -DCMAKE_BUILD_TYPE=Debug 
```


---

# План лекции 

- функция main, точка входа в программу
- Операторы
- Циклы и операторы break; continue;
- Объявления переменных
  - Указатели
  - ссылки
- Введение в сложные типы (структуры) 
- Перегрузка функций 
- Перегрузка операторов
- Средства сборки 
