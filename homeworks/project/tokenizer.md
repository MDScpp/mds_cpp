## Что нужно сделать?

Напишите токенайзер языка. Токенайзер принимает на вход последовательность символов и возвращает последовательность токенов.

## Виды токенов

- **Число:** `42`, `4` или `10`
- **Скобка:** `(` или `)`
- **Symbol:** Начинается с символов `[a-zA-Z_]` и может содержать внутри символы `[a-zA-Z0-9_]`.
- **OperatorToken:** `=`, `+`, `-`, `*`, `/`,  и  `==`,  `!=`,  `<` (если хотите, можете разделить на несколько токенов)
- **Новая строка**
- **Конец Файла(EOF)** 
- **Ваши токены** например ключевые слова  и т.д.



### Пример выражения и потока токенов

```
( 4 +5 )

OpenParen Const(4) Symbol(+) Const(5) CloseParen
```

## Интерфейс

### Базовый тип `Token`

Мы хотим сделать тип `Token`, который мог бы представить все возможные токены. Желательно, чтобы этот тип не мог находиться в состоянии, которому не соответствует ни один реальный токен.

__Плохой__ пример:

```c++
struct Token {
    bool is_number;
    int number;

    bool is_symbol;
    std::string symbol;

    bool is_left_bracket;
    bool is_right_bracket;
};
```

Что не так в этой структуре?

- Чему будет соответствовать объект, у которого `is_number == true` и `is_operator == true`?
- Что если все поля `is_*` выставлены в `false`?
- Как понять, какие значения может принимать поле `operator`?

Наш токен может быть числом или символом(словом) или скобкой, или ключевым символом (+,- def.., NEWLINE,EOF). Для представления такого типа в стандартной библиотеке есть шаблон `std::variant`. Нам нужно сделать несколько типов под каждый из вариантов, а потом подставить типы в параметры шаблона.

__Хороший__ пример:

```c++
#include <variant>
#include <string>

struct SymbolToken {
    std::string name;
};

struct ConstantToken {
    int value;
};

// Используем enum class. 
enum class EmbracingToken {
    LPAREN , RPAREN, COMMA, IF, THEN, ELSE 
};


enum class OperatorToken{
    PLUS, MINUS, MULTIPLY, DIVIDE, EQ_EQ, NOT_EQ, LESS, EQ
};


// это не лучшее решение смешать эти токены, но другие решения тоже не идеальны
enum class UtilityTokens{
    DEF, RETURN, NEWLINE, EOFT 
}




/*
.....
*/


// Чтобы следовать принципу DRY, заводим `using` декларацию.
// Если в будущем добавится новый вариант токена, будет
// достаточно поменять определение в одном месте.
using Token = std::variant<
    SymbolToken,
    ConstantToken,
    EmbracingToken,
    OperatorToken,
    UtilityTokens>;

```

Как работать с таким типом?

```c++
int main (){
    // Токен неявно создаётся из константы, скобки или символа.
    Token a = ConstantToken{5};
    Token b = EmbracingToken::LPAREN;
    Token c = SymbolToken{"x"};


    // Пытаемся достать константу из токена. Если в токене хранится что-то
    // другое, вернётся nullptr.
    if (EmbracingToken* x = std::get_if<EmbracingToken>(&d)) {
        std::cerr << "ConditionToken(" << (*x==EmbracingToken::IF) << ")" << std::endl;
    } else {
        std::cerr << "a is not a ConstantToken";
    }
    return 0 ;
}
```

### Интерфейс токенизатора

Теперь, когда мы смогли сделать тип для токена, нужно определиться с интерфейсом токенизатора. Тут есть разные варианты.

- Читать все токены сразу или по одному.
- Принимать на вход строку или поток `std::istream`.

```c++
// Все сразу из строки.
std::vector<Token> Read(const std::string& string);

// Интерфейс, позволяющий читать токены по одному из потока.
class Tokenizer {
public:
    // Создаёт токенизатор, читающий символы из потока in.
    Tokenizer(std::istream* in);

    // Достигли мы конца потока или нет.
    bool IsEnd();

    // Попытаться прочитать следующий токен.
    // Либо IsEnd() станет true, либо токен можно будет получить через GetToken().
    void Next();

    // Получить текущий токен.
    Token GetToken();
};
```

В этом задании вам нужно реализовать наиболее общий интерфейс.

Как правильно работать с `std::istream`? Можно попробовать читать строки через `operator >>` или `std::getline` и потом итерироваться по ним. Но так мы будем вычитывать из потока больше символов, чем надо. Например:

```c++
std::string Read(std::istream* in) {
    std::string s;
    *in >> s;
    return s;
}

std::stringstream ss;
ss << "4+5";
Read(&ss);
```

Функция `Read` прочитает сразу 3 символа. А нам нужен только один символ, остальные мы будем читать, когда пользователь нас попросит `Next()`.

Гораздо удобнее читать из потока по одному символу через методы `std::istream::peek()` и `std::istream::get()`.

Обратите внимание, что методы читают символ типа `char`, но возвращают `int`. Это сделано для того, чтобы можно было сигнализировать о конце потока - при достижении конца метод вернёт специальное значение `EOF`.





Посмотреть как делают игрушечные языки можно тут: [Kaleidoscope](https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/Chapter4/toy.cpp)
Там все сильно на коленке (очень много глобальных констант), но тем не менее, некоторые здравые идеи можно подчерпнуть.
