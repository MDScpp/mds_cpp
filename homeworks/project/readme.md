
Игрушечный интерпретатор (Это не так страшно, как кажется)

Мы будем реализовывать простенький, функциональный язык программирования, 
который поддерживает один тип переменных - целые числа.

Его синтаксис предельно прост там всего 5 ключевых слов: `def`, `if`, `then` , `else` и `return` .

Операторы  `+`, `-`, `*`, `/`,  и  `==`,  `!=`,  `<`, `,` (да запятая) знака больше не будет, 
булевых операторов тоже, чтобы было проще ( вообще говоря добиться булевых операций можно умножением и сложением). Приоритет у операторов как в с++.

Реализовывать унарную операцию `-` не нужно, это упростит вам жизнь (вы всегда можете написать `(0-a)`).

В языке есть только одна условная операция - тернарная  

В строке может быть только одна инструкция (присваивание переменной значения выражения, или возврат из функции ), или объявление функции ; если строка начинается c объявления функции, тогда на этой строке ничего другого быть не может.

Функции объявляются почти как в python но без точек :

```python

def foo(a , b , c) # начинается тело функции 
d = 100  # отступы не имеют значения 
    a = b * c + a
c = d + 100  
return c*100  # заканчивается тело функции инструкцией возврата 
# обозначаемой ключевым словом return 


# В языке возможны хвостовые рекурсии, 
# остальные рекурсивные вызовы запрещены, нужно выдавать ошибку 

def bar(i,b)
    cond  = i < b
    intermediate_var = bar(i+1,b)
    return  if cond  then  b else intermediate_var

# Можно определять функции внутри функций 
# область их видимости должна быть ограниченна 
# телом той функции в которой они объявлены, 
# функции видно только те которые отъявленны сверху
# Область видимости переменных ограничена телом функции,
# никакие другие функции не могут видеть ваших переменных 
# это позволяет работать с переменными как с константами 
# и сильно упрощает архитектуру интерпретатора 
# 

def pow(base, exp)

    def pow_helper(base, begin , exp)
        cond = 0 < exp 
        next_val = temp * base
        
        return if cond then pow_helper(base, next_val , exp - 1 ) else temp

    return  pow_helper( base, 1 , exp)

```


Переменные можно объявлять только в функциях.


У вас должен быть класс Interpreter который позволяет вызывать ваши функции.

```cpp
class Interpreter {
public:
    Interpreter(std::istream & )
    int run(const std::string& function_name, std::vector<int> args);
};

```


Как с этим ~~жить~~ работать? 

Когда дело доходит до реализации языка, первое, что необходимо, — это способность обрабатывать текстовый файл и распознавать то, что в нем говорится. Традиционный способ сделать это — использовать лексический анализатор для разбиения ввода на токены. Каждый токен, возвращаемый лексером (токенизатором), включает тип (иногда это просто код) токена и потенциально некоторые метаданные (например, числовое значение числа). 

1. Токенайзер 
    - [(лексический анализатор)](tokenizer.md)


2. Синтаксический анализатор 

    - Задача: Построить абстрактное синтаксическое дерево (AST) .

    - Требования:
        Рекурсивный спуск для разбора выражений и операторов.

        Проверка структуры программы (например, def должен начинать объявление функции).

        Ключевые классы AST:
        `NodeAST`  (базовый класс)

        `FunctionDefAST` (имя, параметры, тело).

        `AssignmentAST` (идентификатор, выражение).

        `NumberAST`, `IdentifierAST`, `BinaryOpAST`, `ReturnStmtAST`, `TernaryExprAST`, `FunctionCallAST`, 

        Пример: Для if a < b then 1 else 0 → TernaryExpr(Comparison(a < b), 1, 0).



Для функции bar AST Дерево выглядит так:

```cpp
def bar(i,b)
    cond  = i < b
    intermediate_var = bar(i+1,b)
    return  if cond  then  b else intermediate_var
```

```
FunctionDefAST
├── name: "bar"
├── parameters: ["i", "b"] 
├── body:
    ├── AssignmentAST
    │   ├── left: IdentifierAST("cond")
    │   └── right: BinaryOpAST("<")
    │       ├── left: IdentifierAST("i")
    │       └── right: IdentifierAST("b")
    │
    ├── AssignmentAST
    │   ├── left: IdentifierAST("intermediate_var")
    │   └── right: FunctionCallAST("bar")
    │       └── arguments:
    │           ├── BinaryOpAST("+")
    │           │   ├── left: IdentifierAST("i")
    │           │   └── right: NumberAST(1)
    │           └── IdentifierAST("b")
    │
    └── ReturnStmtAST
        └── TernaryExprAST
            ├── condition: IdentifierAST("cond")
            ├── then_expr: IdentifierAST("b")
            └── else_expr: IdentifierAST("intermediate_var")
```


```cpp
// Parser.h

FunctionDefAST


class Parser {
    // переменные 

public:


private:
    std::unique_ptr<FunctionDefAST> parseFunctionDef();
    std::unique_ptr<StatementAST> parseStatement();
    std::unique_ptr<ExprAST> parseExpression();
    std::unique_ptr<ExprAST> parseTernaryExpr();
    std::unique_ptr<ExprAST> parseLogicalExpr()
    std::unique_ptr<ExprAST> parseAddExpr()
    std::unique_ptr<ExprAST> parseMulExpr()
    std::unique_ptr<ExprAST> parsePrimary()
    // ... остальные методы 
};

```


Приоритет операторов можно учитывать через порядок вызова методов (так проще):
`parseExpression() -> parseTernaryExpr() -> parseLogicalExpr() -> parseAddExpr() -> parseMulExpr() -> parsePrimary()`


```cpp

std::unique_ptr<ExprAST> Parser::parseLogicalExpr( ) {
    auto expr = parseAddExpr();
    
    while ( /* проверяете  EQ_EQ , NOT_EQ, LESS */) {
        // сохраняем тип токена  
        auto right = parseAddExpr();
        expr = /// здесь вы задаете узел AST ,  используя тип токена
    }

    return expr;
}
```


3. Семантический анализ
    - Все переменные и функции объявлены до использования.

    - Нет дублирования имен в одной области видимости.

    - Функции вызываются с правильным числом аргументов.

    - Структуры данных:

    - Иерархическая таблица символов (для вложенных функций).

    - Область видимости: функции видят все функции вверх по иерархии и одну ступень вниз (функции непосредственно в теле определенные ), определение для которых было дано выше (такой подход позволяет проверять вызовы на этапе генерации AST), 



Ваш интерпретатор должен различать 3 вида ошибок:


1. SyntaxError: ошибки синтаксиса. Возникают, когда программа не соответствует формальному синтаксису языка. Или когда программа неправильно использует особые формы.

2. NameError: ошибки обращения к неопределённым переменным.

3. RuntimeError: ошибки времени исполнения. К этим ошибкам относятся все остальные ошибки, которые могут возникнуть во время выполнения программы. Например: неправильное количество аргументов передано в функцию, неправильный тип аргумента.