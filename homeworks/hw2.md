# домашее задание  
создайте класс Matrix 


создайте конструктор, который принимает перывм аргументом количество строк, вторым количество столбцов, третьим значение которым нужно инициализировать элементы;

создайте конструкторы копирования, премещения, копирующий оператор присваивания, перемещающий оператор присваивания 

выделите память для хранения элементов матрицы в нужных конструкторах операторах присваивания; испоьзуйте double 


создайте оператор ()  он должен принадлежать классу принимать два аргумента столбец и строку
с помощью него должно быть возможно менять элементы матрицы и получать их
```cpp
Matrix a(5,6, 3.);
a(1,2) = 5.0; 
```

Перегрузите оператор сравнения == 

Перегрузите арифметические операторы + - *. Они должны реализовывать сложение, разность, умножение матриц друг на друга;  

Для оператора * вам придется реализовать несколько версий, так чтобы минимизировать колличество копирований при всех возможных ситуациях. 
( Для + и - достаточно одной версии (чтобы не мучить вас).)




```cpp
Matrix a(5,5, 3.);

Matrix c = a*Matrix(5,5, 4.);
Matrix d = Matrix(5,5, 4.) *a;
Matrix e = a*a;
Matrix e = Matrix(5,5, 4.) * Matrix(5,5, 4.);
```
**подсказка:** посмотрите на конструктор перемещения 


Сделайте вспомогательную функцию, которая получает указатели и перемножает матрицы. Нужные аргументы придумайте сами. Она вам понадобится, чтобы не копипастить.  


Разделяйте объявления от определений.
ожидется три файла кроме самого CMakeLists.txt





Если матрицы не могут быть умножены или суммированы, выдайте исключение
```cpp 
throw std::invalid_argument("the matrices being summed have incompatible shapes.");
```

Если не может быть выделено достаточно памяти ловите исключение std::bad_alloc вместе с std::invalid_argument
```cpp 
try{
    Matrix c = m * Matrix(5,5, 4.);
}catch (const std::exception& e){
    std::cout << "Error: " << e.what() << '\n';
}
```

# 

используйте set(CMAKE_BUILD_TYPE Debug)

#  
из-за оптимизации компиляторов RVO и NRVO вы можете не увидеть 
в некоторых случаях работу конструктора перемещения (объект создается на месте).

Чтобы посмотреть как это происходит вы можете скомпилировать (это для любопфтных и не обязательно)
код с использованием флага -fno-elide-constructors для clang или GNU
```clang++ -fno-elide-constructors ny_programm.cpp -o my_programm.exe ```

или добавить это в cmake, 
но учтите, если у вас msvc компилятор то это не сработает

```cmake
if (CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(-fno-elide-constructors)
endif()
```



